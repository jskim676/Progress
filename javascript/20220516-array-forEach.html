<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="root">
    <section></section>
    <section></section>
    <section></section>
    <section></section>
    <section></section>
  </div>
</body>
<script>
  const root = document.getElementById('root');
  const sections = Array.from(root.children);

  // const sections = root.children;
  // console.log(sections) 

  /*
  22행의 sections는 콘솔로 확인했을때 HTMLCollection 이라는 배열을 반환한다.
  HTMLCollection을 정확히 정의하면 '유사 배열 (array like)' 이라고 부르며,
  사실 배열처럼 보이는 객체를 의미한다.
  '배열처럼 보인다'라는 애매한 표현의 뜻은 index와 length 값이 생성되지만 자바스크립트 본연의 array(배열)과는 다르게 취급한다는 것이다.
  결론적으로 HTML에 마크업한 '형제들의 모음'은 배열이 아니다.
  HTMLCollection !== array
  따라서 배열 처럼 간단하게 인덱스나 랭스를 사용하는것은 값이 있기때문에 사용할 수 있지만, '배열 전용 함수' 즉 배열 메서드(array method)는 사용할 수 없다.
  배열 메서드(array method)는 매우 자주 활용하는 중요한 내장함수(built-in function)이기때문에 마크업된 요소를 제대로된 배열로 사용하고 싶다면 일련의 가공이 필요하다. HTMLCollection을 진정한 의미로의 array로 만드는 데이터타입 정의를 진행한다.
  ※ 배열메서드가 필요없다면 가공하지 않아도 된다.
  따라서 배열로 데이터타입 가공이 완료되면 다양하고 강력한 함수들을 사용할 수 있다.
  ES6버전부터 즉 자바스크립트 최신버전부터 이것을 간단하게 해결 할 수 있는 내장함수를 지원하기 시작했고, 
  Array.from() 이라는 메서드가 그것이다.
  Array <-- 첫글자 A가 대문자인 것은 '코어', 혹은 자바스크립트 언어 자체를 구성하는 핵심 객체라는 뜻이다.
  .from()이라는 메서드는 '순서 형식이 있는 값들의 모음을 배열로 정의' 해주는 가공을 지원한다.
  따라서 위의 Array.from(HTMLCollection)은 -> 배열로 사용 할 수 있게 해주는 유용한 함수이다.
  */

  console.log(Array.isArray(sections));
  // * Array.isArray()는 해당 변수가 배열인지를 검사하는 타입체크 메서드이다.
  // * typeof로 타입체크를 진행하면 배열의 근원인 객체(object)를 반환한다.

  sections.forEach(function(element, index) {
    console.log(index, element);
    element.textContent = index;
  });

//   for(let i = 0; i<sections.length; i++) {
//   console.log(i, sections[i]);
//   sections[i].textContent = i;
// }


// check point : forEach();

/*
자바스크립트가 지원하는 배열 전용 메서드 .forEach()는 실무에서 매우 자주사용하는 선언방식의 반복문 함수이다.
위의 .forEach()의 작동은 매개변수에 작성한 단어처럼 console에 인덱스와 해당하는 요소를 기록하고 , 해당하는 요소에 textContent 키값에 값을 대입해준 알고리즘이다.
이것을 명령형으로 사용하면 다음과 같다.
for(let i = 0; i<sections.length; i++) {
  console.log(i, sections[i]);
  sections[i].textContent = i;
}
기본 반복 제어문 for()문을 통해 .forEach()의 원형을 구현했다. ※ 원형(polyfill)
for()문으로는 "내가 반복할 갯수를 정해줄게, 정해줄때 이것에서 이거 이것에서 이거만큼 저것을 대입하고 종료시켜" 와 같이 '하나하나' 모두 지정해주는 방식으로 보다 자바스크립트에게 일일히 작동을 시켜주는 방식이며 이러한 패턴을 '명령형 프로그래밍' 이라고 한다. C와 같은 언어들이 명령형 프로그래밍 방식이다.
반면에, forEach() 반복문은 타겟이 배열이라면 알아서 반복시키겠다는 의미이며, 내장 메서드인 특성(매개변수자리가 정해져있는)을 활용하면
간단하게 배열에 대한 반복 실행을 시킬 수 있다. 단점은 '동작'원리를 알기전에 사용하면 매우 의존도가 높아져 적절한 시점에서 for()문을 사용해야할때 막히는 문제가 생긴다.
장점은 일련의 약속(선언)을 해주면 되기때문에 코드가 짧아지는 것은 물론, 오타나 기타 등등 지저분한 실수에 대한 유지보수관점에서 무결성을 갖게 해준다.
*/






</script>
</html> 