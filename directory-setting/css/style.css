/* 
  ? a.css -> b.css 연결
  ? b.css -> index.html 연결
  ? 반응형 웹사이트 형식 등 다양한 스타일링이 요구되는 현재의 시점에서 css는 import 기능을 지원한다.
  * import 기능은 최근에 표준화된 매우 강력한 기능이며 해당 예제 문서인 index.html에서는 import 다발 파일인 style.css '만' 연결되어있는 것을 확인 할 수 있다.
  * 유지보수 관점, 볼륨이 있는 프로젝트인 경우 매우 훌륭한 역할을 하기때문에 반드시 익힐 필요가 있다.
  * 해당 개념이 프로그래밍에서 말하는 모듈(module) 개념이고, 기계로 비유한다면 '부품화'에 해당한다.

  * a.css -> index.html 연결
  * b.css -> index.html 연결
  * c.css -> index.html 연결

  ? 위와 같은 방식으로 css 데이터들을 연결하는 방식은 import를 지원하지 않았을때의 방법으로, 유지보수 및 프로젝트 관리 측면에서 치명적인 약점을 보인다.

  * a.css -> pack.css
  * b.css -> pack.css
  * c.css -> pack.css

  * pack.css -> index.html 연결
  ? 갖가지 css 스타일 시트를 pack이라는 이름의 css파일로 '묶어서' 관리하면
  ? 언제 어디서 로드가 되었는지 아래와 같은 상태로 확인할 수 있기때문에 매우 편리하며
  ? 변수나 class 와 같이 자주 사용하는 항목에 대해서 체계적으로 관리할 수 있다.

  ? SASS(SCSS) 전처리기를 사용한다면
  * 표준 css에서 import를 지원하기 전에는 전처리기에서만 모듈 작업이 가능했으므로 
  * 해당 프로젝트를 전처리기를 사용하여 스타일링 할 것이라는 방향이 잡혔다면
  * 전처리 방식의 모듈을 사용하는 것이 좋다.
  * ※ scss 에서는 @import(표준) -> @use 로 사용된다.

  Todo : @import, @use 혼용여부
  * 회사에서 혹은 팀에서 해당 프로젝트의 빌드스택(사용할 언어, 처리방식)을 결정하는 과정에서 scss와 같은 전처리기를 사용하기로 결정이 났다면 그에 맞는 모듈방식을 사용하는 것이 혼선을 막는 방식이므로 통일할 필요가 있다.
  * scss(전처리기)는 @use 이외에도 변수를 지정하는 방식이 따로 있으므로 주의할 것
  * ※ 해당 예제는 css(표준) 방식으로 설명되어있다.
*/

/* ? @import 순서 */
/* 
  todo : 가장 먼저 읽혀야 할 데이터가 맨 위로 작성되어야 한다.
  
  * 아래의 예제에서는 여러가지 변수(variable)을 사용할 예정이기 때문에 브라우저 초기화보다도 먼저 읽게끔 맨 윗 행(row)에 설정했다.
  * 디자이너로서는 필요한 컬러에셋과 같은 것들을 따로 관리하는 것이 유지보수 측면에서 매우 중요하며
  * 변수를 활용하는 것은 에디터의 도움으로 (캐싱 cache data ) 활용한다.
  * 매번 여러가지를 뜯어서 바꾸는 것이 빈번히 발생하기때문에
  * 최초 설계부터 작성해 나가는 것이 좋다.

  * ※ 도움이 되는 확장플러그인 (extension)
  * css peek : https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peek
  * IntelliSense for CSS class names in HTML :
  * https://marketplace.visualstudio.com/items?itemName=Zignd.html-css-class-completion

  * 기타 매우 다양한 방식의 css 플러그인 들이 존재한다.

*/

@import url(./variable.css);
/* * 변수만 따로 관리 */
@import url(./reset.css);
/* * 브라우저 기본설정을 reset이라는 이름으로 관리 */
@import url(./font.css);
/* * 사용할 font-family를 관리 */
@import url(./class-set.css);
/* 
  todo : class-set.css
  * 임의의 이름으로 css 파일을 지정했지만, class selector를 따로 관리하는 것은 매우 중요하다.
  ? 이유 :
  ? 1. 직접 작성하는 방식으로 class를 따로 관리하기 때문에 오타를 잡아내는데 탁월하다.
  ? 2. css framework 방식의 특징
  ? 2-1. 생산성을 높혀주는 css framework 대부분이 class를 html에서 덧붙이는 방식으로 스타일링을 html마크업과 동시에 끝내기 때문에, 이러한 방식을 채택하는 것이 좋으며 인터넷에 떠돌아다니는 class 방식은 설명용이거나, 정상적인 방식이 아닌 것이 대부분이다.
  ? 3. 권장 : 특별한 경우(id와 같은)가 아니라면 모든 스타일은 class로 활용한다.
*/
@import url(./layout-common.css);
/* 
  ? common : 예제상으로 '공통' 이라는 이름의 css 파일을 제작하였는데, 이것은 디바이스에 구분하지 않는 공통된 디자인 및 스타일링을 지정하는 개념이다.
  ? 아래의 디바이스별 스타일링을 개별적으로 많이 할 수록 작업피로도가 매우 높아지고, 예기치 못한 문제가 발생하기 쉽기 때문에
  ? common.css 와 같은 '공통된 스타일링' 부분에서 유연하게 스타일링 하는 것을 권장한다. 
  ? 특히 디자이너로서 챙겨 사용하고 있는 display 방식중 flex, grid는 
  ? 세부속성을 유려하게 사용할 수록 모든 디바이스에 대응 할 수 있는 능력을 갖추고 있기 때문에
  ? 여러가지 연구가 필요하다.
*/
@import url(./layout-mobile.css);
@import url(./layout-tablet.css);
@import url(./layout-desktop.css);

/* 
  ? 디바이스 별 레이아웃 특징

  * 1. 특정한 조건이 아니라면 모바일을 최우선으로 작업하는 것이 좋다.
  * ※ 웹사이트 접속 중 모바일이 압도적이기 때문
  * 2. 공통이 되는, 혹은 기준이 되는 스타일링 작업(common.css)을 신경써서 작업할 수록 위와같은 디바이스별 스타일링은 그렇게 많은 작업이 필요하지 않는 특성이있다.
  * 2. 다시말해 flex, grid를 고수준으로 활용하는 것 만으로도 작성해야하는 마크업량이 전폭적으로 줄어든다. -> 개발생산성
  * 3. 대표적인 디바이스는 3개 정도로 분류하고는 있지만, 특성에 따라 디바이스별 대응 단계는 늘릴수도 줄일수도 있다.
  * 3.1 ex> 모바일가로, 모바일세로, 태블릿가로, 태블릿세로, FHD 모니터 QHD(FHD 두배) 모니터, fivot(세로로 돌린) 모니터, wide(표준 종횡비보다 가로로 넓은) 모니터, 폴더블 스마트폰, TV 등등 접속 디바이스는 날이 갈수록 다양해지기 때문에
  * 3.2 필요한 이슈가 발생할 때마다 대응 시킬 필요가 있다.

*/